module trans/semantics/functions

imports
  trans/semantics/values

/*
* Function definitions
*/
signature
  arrows
    List(FunDef) -load-> U
    FunDef -load-> U
    FunDef -fun2val-> V

rules

  fs : List(FunDef) :: C, E -load-> u :: C'', E''
  where
    fs => [f | fs']
    < {
      f :: C, E -load-> _ :: C', E';
      fs' :: C', E' -load-> _ :: C'', E'';
      U() => u
    } + {
      U() => u;
      C => C'';
      E => E''
    }.

//  [] : List(FunDef) -load-> U().
//  
//  [f | fs] : List(FunDef) -load-> U()
//  where
//    f -load-> _;
//    fs -load-> _.

  FunDef(name, params, body) :: C C(E), E E' -load-> U() :: C C({entry, E}), E {entry, E'}
  where
    {name |--> FunV(name, params, __Block2Stmt__(body))} => entry.

rules

  FunCall(name, args) --> v
  where
    lookup(name) --> FunV(_, params, body);
    args --> vargs;
    invoke(vargs, params, body) --> v.

/*
* Function calls
*/
signature
  constructors
    invoke: List(V) * List(String) * Stmt --> V
    bind: List(V) * List(String) --> E
  
  sorts
    ReturnHandler
  
  constructors
    doReturn : V -> ReturnHandler // will throw a ReturnException with the value and the semantic components
    onReturn : Stmt -> ReturnHandler // will catch a ReturnException with the value and the semantic components
  
  arrows
    ReturnHandler --> V // natively implemented
  
  arrows
    List(Expr) --> List(V)

  constructors
    es_aux : List(Expr) * List(V) --> List(V)
    bind_aux : List(V) * List(String) * E --> E
    
rules  

  invoke(vseq, parseq, stmt) :: E --> v :: E
  where
    bind(vseq, parseq) :: E --> E' :: E _;
    onReturn(stmt) :: E' --> v :: E _.
  
//// this is incorrect because it builds the list of values in reverse
//  es_aux(es, acc) :: C, E --> vs :: C'', E''
//  where
//    es => [e | es']
//    < {
//      e :: C, E --> v :: C', E';
//      es_aux(es', [v | acc]) :: C', E' --> vs :: C'', E''
//    } + {
//      acc => vs;
//      C => C'';
//      E => E''
//    }.
//  
//  es : List(Expr) --> vs
//  where
//    es_aux(es, []) --> vs.
  
  es : List(Expr) :: C, E --> vs :: C'', E''
  where
    es => [e | es']
    < {
      e :: C, E --> v :: C', E';
      es' :: C', E' --> vs' :: C'', E'';
      [v | vs'] => vs
    } + {
      [] => vs;
      C => C'';
      E => E''
    }.
  
//  [] : List(Expr) --> [].
//  
//  [e | es] : List(Expr) --> [v | vs]
//  where
//    e --> v;
//    es --> vs.
  
  
  bind_aux(vs, params, Ecall) :: C, E --> Ecall' :: C', E'
  where
    vs => [v | vs']
    < {
      params => [p | ps'];
      bind_aux(vs', ps', {p |--> v, Ecall}) :: C, E --> Ecall' :: C', E'
    } + {
      Ecall => Ecall';
      C => C';
      E => E'
    }. 
    
  bind(vs, params) :: C c@C(Etop), E --> Ecall :: C c, E
  where
    bind_aux(vs, params, Etop) --> Ecall.
    
  
//  bind(vs, params) :: E, C --> Ecall :: E', C'
//  where
//    vs => []
//    < {
//      params => [];
//      C => C(Etop);
//      Etop => Ecall;
//      E => E';
//      C => C'
//    } + {
//      vs => [v | vs'];
//      params => [p | ps];
//      bind(vs', ps) :: E, C --> Ebind :: E', C';
//      {p |--> v, Ebind} => Ecall
//    }.
  
//  bind([], []) :: C c@C(E) --> E :: C c. 
//  
//  bind([v | vs], [p | ps]) --> {p |--> v, E}
//  where
//    bind(vs, ps) --> E.
  
  ReturnVoid() --> U()
  where
    doReturn(NullV()) --> _.

  Return(v) --> U()
  where
    doReturn(v) --> _.




module trans/semantics/functions

imports
  trans/semantics/values

/*
* Function definitions
*/
signature
  arrows
    List(FunDef) -load-> U
    FunDef -load-> U
    FunDef -fun2val-> V
    ID -id2str-> String
    List(ID) -id2str-> List(String)

rules

  fundefs : List(FunDef) :: C, E -load-> U() :: C'', E''
  where
    fundefs => [f | fs]
    < {
      f :: C, E -load-> _ :: C', E';
      fs :: C', E' -load-> _ :: C'', E''
    } + {
      C => C'';
      E => E''
    }.

  FunDef(nameid, paramids, body) :: C C(E), E E' -load-> U() :: C C({entry, E}), E {entry, E'}
  where
    nameid -id2str-> name;
    paramids -id2str-> params;
    {name |--> FunV(name, params, __Block2Stmt__(body))} => entry.

  __String2ID__(name) -id2str-> name.
  
  ids : List(ID) -id2str-> names
  where
    ids => [id | ids']
    < {
      id -id2str-> name;
      ids' -id2str-> names';
      [name | names'] => names
    } + {
      [] => names
    }.

rules

  FunCall(name, args) --> v
  where
    lookup(name) --> FunV(_, params, body);
    args --> vargs;
    invoke(vargs, params, body) --> v.

/*
* Function calls
*/
signature
  constructors
    invoke: List(V) * List(String) * Stmt --> V
    bind: List(V) * List(String) --> E
  
  sorts
    ReturnHandler
  
  constructors
    doReturn : V -> ReturnHandler // will throw a ReturnException with the value and the semantic components
    onReturn : Stmt -> ReturnHandler // will catch a ReturnException with the value and the semantic components
  
  
  
  arrows
    ReturnHandler --> V // natively implemented
  
  arrows
    List(Expr) --> List(V)

rules  

  invoke(vseq, parseq, stmt) :: E --> v :: E
  where
    bind(vseq, parseq) :: E --> E' :: E _;
    onReturn(stmt) :: E' --> v :: E _.
  
  es : List(Expr) :: E, C --> vs :: E'', C''
  where
    es => [e | es']
    < {
      e :: E, C --> v :: E', C';
      es' :: E', C' --> vs' :: E'', C'';
      [v | vs'] => vs
    } + {
      E => E'';
      C => C'';
      [] => vs
    }.

  
  bind(vs, params) :: E, C --> Ecall :: E', C'
  where
    vs => []
    < {
	    params => [];
	    C => C(Etop);
	    Etop => Ecall;
	    E => E';
	    C => C'
	  } + {
	    vs => [v | vs'];
      params => [p | ps];
      bind(vs', ps) :: E, C --> Ebind :: E', C';
      {p |--> v, Ebind} => Ecall
	  }.
  
  ReturnVoid() --> U()
  where
    doReturn(NullV()) --> _.

  Return(v) --> U()
  where
    doReturn(v) --> _.




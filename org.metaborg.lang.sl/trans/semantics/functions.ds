module trans/semantics/functions

imports
  trans/semantics/values

/*
* Function definitions
*/
signature
  arrows
    List(FunDef) -load-> U
    FunDef -load-> U
    FunDef -fun2val-> V
    ID -id2str-> String
    List(ID) -id2str-> List(String)

rules

  [] : List(FunDef) -load-> U().
  
  [f | fs] : List(FunDef) -load-> U()
  where
    f -load-> _;
    fs -load-> _.

  FunDef(nameid, paramids, body) :: C C(E), E E' -load-> U() :: C C({entry, E}), E {entry, E'}
  where
    nameid -id2str-> name;
    paramids -id2str-> params;
    {name |--> FunV(name, params, __Block2Stmt__(body))} => entry.

  __String2ID__(name) -id2str-> name.
  
  [] : List(ID) -id2str-> [].
  
  [id | ids] : List(ID) -id2str-> [name | names]
  where
    id -id2str-> name;
    ids -id2str-> names.
  
rules

  FunCall(name, args) --> v
  where
    lookup(name) --> FunV(_, params, body);
    args --> vargs;
    invoke(vargs, params, body) --> v.

/*
* Function calls
*/
signature
  constructors
    invoke: List(V) * List(String) * Stmt --> V
    bind: List(V) * List(String) --> E
  
  sorts
    ReturnHandler
  
  constructors
    doReturn : V -> ReturnHandler // will throw a ReturnException with the value and the semantic components
    onReturn : Stmt -> ReturnHandler // will catch a ReturnException with the value and the semantic components
  
  arrows
    ReturnHandler --> V // natively implemented
  
  arrows
    List(Expr) --> List(V)

rules  

  invoke(vseq, parseq, stmt) :: E --> v :: E
  where
    bind(vseq, parseq) :: E --> E' :: E _;
    onReturn(stmt) :: E' --> v :: E _.
  
  [] : List(Expr) --> [].
  
  [e | es] : List(Expr) --> [v | vs]
  where
    e --> v;
    es --> vs.
  
  bind([], []) :: C c@C(E) --> E :: C c. 
  
  bind([v | vs], [p | ps]) --> {p |--> v, E}
  where
    bind(vs, ps) --> E.
  
  ReturnVoid() --> U()
  where
    doReturn(NullV()) --> _.

  Return(v) --> U()
  where
    doReturn(v) --> _.




module trans/semantics/control-flow

imports
  trans/semantics/desugared-sig
  trans/semantics/values

// While loops
signature
  constructors
  whileHelper : Expr * Block -> Stmt

rules
  
  While(e, block) --> U()
   where
     onBreak(onContinue(whileHelper(e, block))) --> _.
 
   w@whileHelper(e, block) :: C, E --> u :: C''', E'''
   where
     e :: C, E --> BoolV(bv) :: C', E';
     bv == true
     < {
     	__Block2Stmt__(block) :: C', E' --> _ :: C'', E'';
     	w :: C'', E'' --> _ :: C''', E''';
     	U() => u
     } + {
     	E' => E''';
     	C' => C''';
     	U() => u
     }.
 

signature
//  sorts
//    RepeatingNode
  
//  native constructors
//    SLRepeatingNode : Expr * V * Block -> RepeatingNode
  
//  arrows
//    RepeatingNode --> U
  
  sorts
    BreakHandler
    ContinueHandler
    
  constructors
    doBreak : BreakHandler // will throw a BreakException with the value and the semantic components 
    onBreak : Stmt -> Stmt // will handle a BreakException with the value and the semantic components
    doContinue : ContinueHandler // will throw a ContinueException with the value and the semantic components
    onContinue : Stmt -> Stmt // will handle a ContinueException with the value and the semantic components  

   arrows
     BreakHandler --> U // natively implemented
     ContinueHandler --> U // natively implemented

rules
  
//  While(e, block) --> SLRepeatingNode(e, BoolV(true), block).
  
  Continue() --> u
  where
    doContinue() --> u.
  
  Break() --> u
  where
    doBreak() --> u.

rules

  IfThenElse(e, then, else) :: C, E --> u :: C'', E''
  where
    e :: C, E --> BoolV(bv) :: C', E';
    bv == true
    < {
    	then :: C', E' --> _ :: C'', E'';
    	U() => u
    } + {
    	else :: C', E' --> _ :: C'', E'';
    	U() => u
    }.
  
  Stmt(e) --> U()
  where
    e --> _.
  
  __Block2Stmt__(Block(ss)) --> U()
  where
    ss --> _.
  
//  __Block2Stmt__(Block(ss)) :: C, E --> U() :: C'', E''
//  where
//    ss => [s | xs]
//    < {
//      s  :: C, E --> _ :: C', E';
//      __Block2Stmt__(Block(xs)) :: C', E' --> _ :: C'', E''
//    } + {
//      C => C'';
//      E => E''
//    }.

signature
  arrows
    List(Stmt) --> U

rules

  stmts : List(Stmt) :: C, E --> U() :: C'', E''
  where
    stmts => [s | xs]
    < {
      s :: C, E --> _ :: C', E';
      xs :: C', E' --> _ :: C'', E''
    } + {
      C => C'';
      E => E''
    }.

//  [] : List(Stmt) --> U().
//  
//  [s | xs] : List(Stmt) --> U()
//  where
//    s --> _;
//    xs --> _.


module trans/semantics/control-flow

imports
  trans/semantics/desugared-sig
  trans/semantics/values

// While loops
signature
  constructors
  whileHelper : Expr * Block -> Stmt

rules
  
  While(e, block) --> U()
   where
     onBreak(onContinue(whileHelper(e, block))) --> _.
 
   w@whileHelper(e, block) :: C, E --> u :: C''', E'''
   where
     e :: C, E --> BoolV(bv) :: C', E';
     bv == true
     < {
     	__Block2Stmt__(block) :: C', E' --> _ :: C'', E'';
     	w :: C'', E'' --> _ :: C''', E''';
     	U() => u
     } + {
     	E' => E''';
     	C' => C''';
     	U() => u
     }.
 

signature
//  sorts
//    RepeatingNode
  
//  native constructors
//    SLRepeatingNode : Expr * V * Block -> RepeatingNode
  
//  arrows
//    RepeatingNode --> U
  
  sorts
    BreakHandler
    ContinueHandler
    
  constructors
    doBreak : BreakHandler // will throw a BreakException with the value and the semantic components 
    onBreak : Stmt -> Stmt // will handle a BreakException with the value and the semantic components
    doContinue : ContinueHandler // will throw a ContinueException with the value and the semantic components
    onContinue : Stmt -> Stmt // will handle a ContinueException with the value and the semantic components  

   arrows
     BreakHandler --> U // natively implemented
     ContinueHandler --> U // natively implemented

rules
  
//  While(e, block) --> SLRepeatingNode(e, BoolV(true), block).
  
  Continue() --> u
  where
    doContinue() --> u.
  
  Break() --> u
  where
    doBreak() --> u.

rules

  IfThenElse(e, then, else) :: C, E --> u :: C'', E''
  where
    e :: C, E --> BoolV(bv) :: C', E';
    bv == true
    < {
    	__Block2Stmt__(then) :: C', E' --> _ :: C'', E'';
    	U() => u
    } + {
    	__Block2Stmt__(else) :: C', E' --> _ :: C'', E'';
    	U() => u
    }.
  
  __Block2Stmt__(b)  :: C, E --> U() :: C', E'
  where
    b => Block(stmt)
    < {
      stmt :: C, E --> _  :: C', E'      
    } + {
      true == true;
      C => C';
      E => E'
    }.
  
//  Block(stmt) --> stmt.
//  
//  EmptyBlock() --> U().
  
  Stmt(e) --> U()
  where
    e --> _.
  
  Seq(stmt1, stmt2) --> U()
  where
    stmt1 --> _;
    stmt2 --> _.
  